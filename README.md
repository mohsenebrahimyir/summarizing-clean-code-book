
# مقدمه
#

جدید ویرایش نسخه ازمایشی 
این دست نوشته خلاصه شده ترجمه کتاب کد تمیز است که می‌توانید از طریق لینک زیر به آن دسترسی پیدا کنید:

https://codetamiz.vercel.app/

# فصل یک - کد تمیز

## اهمیت کد تمیز
-  با ساخته شدن شلختگی، بهره‌وری تیم همچنان رو به کاهش می‌رود، و در نهایت به صفر نزدیک می‌شود.
-  غیر حرفه ای است که برنامه‌نویسان به خواسته مدیرانی که ریسک ایجاد شلختگی‌ها را نمی‌فهمند تن در دهند.
-   شما با ایجاد شلختگی به ضرب الاجل نمیرسید. در واقع، شلختگی فورا شما را کند می‌کند و شما را مجبور می‌کند که ضرب الاجل را از دست بدهید. تنها راه برای رسیدن به ضرب الاجل- تنها راه سریع پیشبرد کار- این است که همیشه کد را تا حد ممکن تمیز نگه دارید.

## هنر کد تمیز

-    نوشتن کد تمیز بسیار شبیه به نقاشی کشیدن است.
-    قدرت تشخیص هنر خوب از بد به معنای این نیست که بلدیم چگونه نقاشی کنیم.
-    یک برنامه‌نویس که کد تمیز می‌نویسد، هنرمندی است که می‌تواند یک صفحه خالی بگیرد و از طریق یک سری دگرگونی‌ها آن را به یک سیستم با کدگذاری زیبا تغییر دهد.
-    خواندن کد تمیز لذت بخش است. خواندن آن باید لبخند را به لبان شما بیاورد، هماگونه که یک جعبه موسیقی خوش ساخت و یا یک ماشین با طراحی زیبا باعث می‌شود لبخند بزنید.
- کد بد شلختگی را وسوسه می‌کند تا رشد کند! وقتی دیگران کد بد را تغییر می‌دهند، متمایل به بدتر کردن آن هستند.
- وقتی ساختمانی پنجره‌های شکسته دارد اینظور به نظر می‌رسد که کسی به آن اهمیتی نمی‌دهد. بنابراین دیگران هم به آن ساختمان اهمیتی نمیدهند. آنها اجازه می‌دهند تا پنجره‌های بیشتری شکسته شود.  حتی خودشان هم شروع به شکستن پنجره‌ها می‌کنند.
- کد تمیز ساده و سر راست است. کد تمیز مثل یک نثر خوب نوشته شده است. کد تمیز هرگز هدف طراح را مبهم نمی‌کند بلکه پر از انتزاعات واضح و خطوط کنترل سر راست است.
- کد تمیز میتواند بجز نویسنده اصلی آن، توسط یک توسعه‌دهنده دیگر نیز خوانده شود و بهبود یابد. 
-  میان کدی که خواندن آن آسان است و کدی که تغییر آن آسان است تفاوت وجود دارد.
-  **کد، بدون تست، تمیز نیست**. 
  -  مهم نیست که چقدر زیبا باشد، هر چقدر هم که قابل خواندن و در دسترس باشد، اگر آزمایش نشده باشد، کثیف است.
- کوچکتر بهتر است.
- کد باید به شکلی تهیه شود که برای انسانها خوانا باشد
- اهمیت دادن
- کد تمیز کدی است که از آن مراقبت شده است.
- شخصی وقت خود را برای ساده و منظم نگه داشتن آن صرف کرده است.
- کد ساده:
  - تمام تست‌ها را اجرا می‌کند؛
  -  بدون (کد اضافه)Duplicate است.
  -  تمام ایده‌های طراحی موجود در سیستم را بیان می‌کند.
  -  تعداد موجودیت‌هایی چون کلاسها، متدها، توابع و موارد مشابه را به حداقل می‌رساند.
-   وقتی کد تمیز را می‌خوانید به هیچ وجه تعجب نکنید. در واقع، شما حتی تلاش زیادی هم نمی کنید. شما آن را خواهید خواند، و تقریباً همان چیزی است که انتظار دارید
-   هر ماژول مقدمات را برای مرحله بعد تنظیم می‌کند.
-   **این زبان نیست که برنامه‌ها را ساده جلوه دهد. این برنامه‌نویس است که باعث می‌شود زبان ساده به نظر برسد!**

## مکتب فکری

- در فنون رزمی هیچ یک از این مکاتب مختلف کاملاً درست نیستند. با وجود این، در درون یک مکتب خاص به نظر می‌رسد که آموزه‌ها و فنون صحیح هستند.
-  دفعه بعد که شما یک خط از یک کد را نوشتید، به یاد داشته باشید که شما نویسنده ای هستید که برای خوانندگانی که تلاش شما را قضاوت می‌کنند، می‌نویسید.
-  ویرایشگرانی مانند Emacs داشتیم که هرگونه فشار به صفحه کلید را ردیابی می‌کردند. می‌توانید یک ساعت کار کنید و بعد از آن کلیه ویرایش‌های خود را مانند یک فیلم پر سرعت پخش کنید. وقتی این کار را کردم، نتایج جالب توجه بود. 
- همیشه بخشی از تلاشمان برای نوشتن کد جدید، برای خواندن کد قدیمی صرف می‌شود.
- نسبت زمانی که صرف خواندن میکنید در مقابل زمانی که صرف نوشتن میکنید بیش از 10: 1 است.
-  از آنجا که این نسبت بسیار زیاد است، می‌خواهیم خواندن کد آسان باشد، حتی اگر این کار نوشتن را سخت‌تر کند.
-  آسان تر کردن خواندن در واقع نوشتن آن را آسان تر می‌کند.
-  کد باید در طول زمان تمیز نگه داشته شود. با گذشت زمان، همه ما شاهد پوسیدن و کاهش درجه ارزش کد هستیم. بنابراین ما باید نقش فعالی در جلوگیری از این تخریب داشته باشیم.
-  كد خود را كمي تميزتر از زماني كه آن را رها کرده بوديم کنیم، كد به سادگي نمي تواند پوسيده شود. 
-  پاکسازی لازم نیست چیز بزرگی باشد:
  - بهتر کردن نام یک متغیر،
  - شکستن یک تابع نسبتا بزرگ به توابع کوچکتر،
  - از بین بردن یک تکثیر
  -  پاک کردن یک عبارت شرطی ترکیبی.
- **پیشرفت مداوم جز ذاتی حرفه ای بودن است**

# فصل دو - اسامی با معنی

- ما همه چیز را نام‌گذاری می‌کنیم.

## استفاده از اسم‌های بیان کننده منظور

- انتخاب‌کردن اسم‌های خوب زمان‌بر است ولی زمان بیشتری از آنچه می‌گیرد را ذخیره می‌کند.
- به اسم هایتان توجه کنید و هر وقت اسم‌های بهتری یافتید، آنها را عوض کنید.
- اسم باید بگوید که چرا وجود دارد، چه می‌کند و چگونه استفاده می‌شود.
- اگر اسمی به کامنت نیاز داشته باشد،پس منظور خود را نمی‌رساند.

## خودداری از دادن اطلاعات اشتباه

- خودداری از دادن اطلاعات اشتباه
-  کلمات hp ،aix و sco نام‌های ضعیفی برای متغیرها هستند زیرا از اسامی یونیکس پلتفرم هستند.
-  هرگز به یک لیست از اکانت‌ها اسم accountList را ندهید زیرا آن واقعا یک لیست است ولی کلمه List به معنی چیزی است که به برنامه نویس ها اختصاص دارد. پس accountGroup یا bunchOfAccounts یا فقط accounts اسم‌های بهتری هستند.
-  از استفاده از اسم‌هایی که تفاوت‌های کوچکی با هم دارند خودداری کنید: 
  - XYZControllerforEfficientHandlingOfStringsin 
  - XYZControllerforEfficientStorageOfStrings
-  در انتخاب اسم به تلفظ و املا آن دقت کنید. استفاده از اسم با تلفظ اشتباه نوعی اطلاعات غلط است.
-  یک مثال از نام‌هایی که اطلاعات غلط می‌دهند، نام‌هایی هستند که از حروفی استفاده می‌کنند که شبیه حروف دیگر هستند. مثلا حرف I و L، اگر به صورت I و l نوشته شوند،مطمئنا اشتباه گرفته میشوند. همچنین حرف lو1 نیز ممکن است اشتباه گرفته شوند.

## تفاوت‌های با معنی ایجاد کنید

-  شما نمی‌توانید از یک اسم در دو متغیر مختلف استفاده کنید،شما مجبورید یکی از اسم‌ها را کمی تغییر دهید.  افزودن اعداد یا حروف اضافه هرگز کافی نیست. اگر نام‌ها باید متفاوت باشند، پس معنی آنها نیز باید فرق کند.
-  اسامی شامل سری اعداد (a1,a2,…,aN) با نام گذاری اصولی در تضاد هستند. این اسم‌ها اطلاعات غلط نمی‌دهند،چون اصلا اطلاعاتی نمی‌دهند و کاملا بی معنی هستند.
-  حروف اضافه(noise words) موارد بی معنی دیگری هستند.
  - شما کلاسی به اسم Product دارید. اگر شما کلاس‌های دیگری با اسم‌های ProductInfo یا ProductData بسازید،
  - شما می‌توانید از a برای همه متغیرهای محلی و از the برای همه آرگومنت‌های توابعتان استفاده کنید. در حقیقت مشکل از جایی شروع می‌شود که شما یک متغیر را theZork بنامید، فقط به این دلیل که متغیر دیگری به نام Zork دارید.
  - کلمه Variable هیچوقت نباید در اسم یک متغیر نمایان شود. واژه table نباید در اسم یک Table نشان داده شود. چرا فکر میکنید NameString بهتر از Name است؟ آیا ممکن است Name یک عدد اعشاری باشد؟اگر جواب بله است،پس شما کل قوانین را زیر سوال برده اید!
  - فرض کنیدکلاسی به اسم Customer و کلاسی دیگر به اسم CustomerObject دارید.از اختلاف این دو اسم چه چیزی دستگیرتان می‌شود؟ کدام یک از این دو اسم، بهتر میتواند تاریخچه پرداخت‌های یک مشتری را نشان دهد؟
- استفاده درست از حروف اضافه:
  - `getActiveAccount();`
  - `getActiveAccounts();`
  - `getActiveAccountInfo();`

- دقت کنید که حروف اضافه چه تغییری در اسم متغیر شما می‌دهند. تفاوت متغیر moneyAmount از money غیرقابل تشخیص است. تفاوت customerInfo از customer نیز همینطور.accountData از account و theMessage از message. اسامی قابل تشخیص باید تفاوت خود را به خواننده نشان دهند.

## از اسم‌های قابل تلفظ استفاده کنید

- مغز ما کلمات را با توجه به تلفظ آنها درک می‌کند، نه نوشتار آنها. اگر نمی‌توانید یک اسم را تلفظ کنید، نمی‌توانید درباره آن بحث کنید،بدون اینکه مثل یک احمق صدا در بیاورید!

## از اسامی قابل جستجو استفاده کنید

- احتمالا پیدا کردن MAX_CLASSES_PER_STUDENT در یک متن راحت است، اما مثلا پیدا کردن عدد 7 در یک متن طولانی، سخت و زمان بر است.
- در هر کدی، نام‌های طولانی‌تر، بر نام‌های کوتاه‌تر برتری دارند و نام‌های قابل جستجو بر ثابت‌ها.
- طول یک نام باید با دامنه استفاده آن مطابقت داشته باشد.

## از رمزگذاری خودداری کنید

- نام‌های رمزگذاری شده به سادگی قابل تلفظ نیستند و برای توسعه دهندگان جدید دردسر ایجاد می‌کنند،زیرا هر کارمند جدید باید زبان رمزنگاری شما را بیاموزد که خود باعث فشار روحی زیادی است.

## پیشوندهای متغیر

-  هرچه آن را بیشتر بخوانند، کمتر the را میبینند.در نهایت پیشوندها به صورت تصادفی دیده می شوند و نشانگر کد قدیمی تر هستند.

## واسط‌ها (interface) و پیاده‌سازی‌ها

- IShapeFactions و ShapeFective؟ من ترجیح می‌دهم واسط را بدون آراستگی رها کنم. پیشوند i، که در میان میراث (legacy) این روزها معمول است، در بهترین حالت حواس پرتی و در بدترین اطلاعات اضافی است.

## از نگاشت ذهنی خودداری کنید

- خوانندگان نباید مجبور باشند که نام انتخابی شما را در ذهنشان به نام دیگری که از قبل می‌شناسند ترجمه کنند.  این مشکل معمولاً ناشی از انتخابی است که نه از دامنه اصطلاحات مسئله استفاده کرده است و نه از دامنه واژه‌های راه حل.
- یک دامنه نام برای شمارشگر حلقه ای که کوچک باشد و هیچ نام دیگری با آن به تناقض نرسد، i یا j یا k است (هرچند هیچگاه l نامگذاری نمی‌شود). دلیل این امر آن است که این نام‌های تک حرفی از قدیم برای شمارشگر حلقه استفاده شده اند. با این وجود، در بیشتر زمینه‌های دیگر، یک نام تک حرفی انتخاب بدی است.
- یک تفاوت بین یک برنامه نویس هوشمند و یک برنامه نویس حرفه ای در این است که حرفه ای می‌فهمد که شفافیت پادشاه است. حرفه‌ای ها به خوبی از توانایی‌های خود برای نوشتن کدی که دیگران می‌توانند آن را درک کنند استفاده می‌کنند.

## نام کلاس‌ها

- کلاسها و اشیاء باید دارای نام یا عبارت اسمی مانند Customer، WikiPage، Account و AdressParser باشند. از کلماتی مانند Manager، Processor، Data یا Info برای نام کلاس خودداری کنید. نام کلاس نباید یک فعل باشد.

## نام متدها

- اسم متدها باید دارای فعل یا عبارت فعلی مانند postPayment، DeletePage یا save باشند. Accessorها، mutator ها و predicate ها را باید با مقدار خودشان نامگذاری کرد و با در نظر گرفتن استانداردهای javabean، با پیشوندهای get، set و is نام گذاری کرد.

## بانمک نباشید

- اگر نام‌ها خیلی هوشمندانه باشند، فقط در ذهن افرادی که از نظر شوخ طبعی به نویسنده شبیه هستند، و فقط تا زمانی که این افراد این شوخی را به خاطر می‌آورند، ماندگار می‌شوند. 
- آیا آنها می‌دانند تابعی به نام HolyHandGrenade قرار است چه کاری انجام دهد؟ مطمئنا، بانمک است، اما شاید در این حالت DeleteItems نام بهتری باشد. شفافیت را در برابر سرگرمی انتخاب کنید.
- **آن چیزی را بگویید که منظورتان است. منظورتان همان چیزی است که می‌گویید.**

## برای هر مفهوم یک کلمه انتخاب کنید

- یک کلمه را برای یک مفهوم مجزا انتخاب کنید و به آن بچسبید. به عنوان مثال fetch ،retrieve و get به عنوان نام متدهای معادل در کلاسهای مختلف گیج کننده است. چگونه به یاد خواهید آورد که نام کدام متد در کدام کلاس ذکر شده است؟
- اسامی توابع باید مستقل واضح باشند، و آنها باید سازگار باشند تا شما بتوانید متد صحیح را بدون جستجوهای اضافی انتخاب کنید.
- واژه نامه نامتناقض یک لطف بزرگ به برنامه نویسانی است که باید از کد شما استفاده کنند.

## با ایهام ننویسید

- از استفاده از یک کلمه برای دو منظور مختلف خودداری کنید. استفاده از یک اصطلاح یکسان برای دو ایده متفاوت در اصل یک ایهام است.
- ما می‌خواهیم کد ما به جای اینکه یک مطالعه عمیق و مفهومی باشد، سریع خوانده شود. 

## از دامنه واژگان مربوط به راه حل استفاده کنید

- به یاد داشته باشید افرادی که کد شما را می‌خوانند، برنامه نویس هستند. بنابراین از اصطلاحات علوم کامپیوتر، نام الگوریتم ها، نام الگوها، اصطلاحات ریاضی و موارد دیگر استفاده کنید. عاقلانه نیست که هر نام را از دامنه صورت مسئله انتخاب کنیم زیرا ما نمی‌خواهیم همکاران ما مجبور به فرار از مشتری ای باشند که چون هر مفهوم را با نام دیگری میشناسد، معنی هر کلمه را می پرسد.
- موارد فنی بسیار زیادی وجود دارد که برنامه نویسان باید انجام دهند. انتخاب نام‌های فنی برای آن موارد معمولاً مناسب ترین روش است.

## از دامنه واژگان صورت مسئله استفاده کنید

- وقتی "اصطلاح برنامه نویسی" برای کاری که انجام می‌دهید وجود ندارد، از دامنه صورت مسئله برای انتخاب نام استفاده کنید. حداقل برنامه نویسی که کد شما را نگهداری می‌کند می تواند از یک متخصص دامنه سوال کند که منظور چیست.
- دی که ارتباط بیشتری با مفاهیم مربوط به صورت مسئله دارد باید دارای نامهایی باشد که از دامنه صورت مسئله گرفته شده است.

## ساختارهای با معنی اضافه کنید

- تنها چند نام وجود دارند که به خودی خود معنی دارند و اکثر نام‌ها به خودی خود بی معنی اند.
- درعوض، باید با قرار دادن آنها در کلاسها، توابع یا مکانهای نامگذاری شده، خوانندتان را در جریان وضوع قرار دهید. 
- وقتی همه موارد دیگر شکست بخورد، ممکن است استفاده از پیشوند برای نام به عنوان آخرین راه حل اساسی مورد استفاده قرار گیرد.

## متن(context) بیخود اضافه نکنید.

-  معمولا تا زمانی که نامهای کوتاهتر واضح باشند، از نامهای طولانی تر بهتر هستند. هیچ متنی بیشتر از آن چیزی که لازم است، به یک نام اضافه نکنید. نام های accountAddress و customerAddress نام های خوبی برای نمونه های کلاس Address هستند اما برای نام کلاس ها مناسب هستند.

## سخن پایانی

- سخت‌ترین کار در انتخاب نام‌های خوب این است که به مهارت‌های توصیفی خوب و پیشینه فرهنگی مشترک نیاز دارد.
- مردم همچنین از ترس اینکه برخی از توسعه دهندگان دیگر مورد تخریب قرار گیرند، از تغییر نام چیزها می‌ترسند. ما این ترس را نداریم و وقتی اسم ها به چیز بهتری تغییر می‌کنند واقعاً سپاسگزاریم.
- . بیشتر مواقع ما واقعا نام کلاس‌ها و متدها را به خاطر نمی‌آوریم. ما از ابزارهای مدرن برای کلنجار رفتن با جزئیاتی از این دست استفاده می‌کنیم تا بتوانیم تمرکز خود را بر این مسئله بگذاریم که آیا کد باید مانند پاراگراف‌ها و جملات خوانده شود، یا شبیه به جدول‌ها و ساختار داده‌ها (یک جمله همیشه بهترین راه برای نمایش داده‌ها نیست)

# توابع

## کوچک بودن!

- اولین قانون برای توابع این است که آنها باید کوچک باشند.
- قانون دوم این است که آنها باید از آن هم کوچکتر باشند.
- توابع باید به سختی به طول 20 خط برسند.
- هر تابع در این برنامه فقط دو، سه یا چهار خط طول داشت. 
- هر کدام واضح و آشکار بود.
-  هر کدام داستانی را بیان می کرد. 
-  و هر کدام شما را به ترتیبی قانع‌کننده به سمت بعدی سوق می‌دادند.
-   این مقدار همانی مقداری است که توابع شما باید به آن اندازه کوچک باشند!

## بلوک ها و تو رفتگی ها

-  بلوک های موجود در جملات شرطی، حلقه ها، و نظایر آن، باید به اندازه یک خط باشند.  احتمالاً آن خط باید یک فراخوانی تابع باشد.
-  توابع نباید برای نگه‌داشتن ساختارهای تو در تو به اندازه کافی بزرگ باشند.
-  سطح تورفتگی یک تابع نباید بیشتر از یک یا دو باشد. این امر البته باعث می شود خواندن و درک توابع آسان تر شود.

## انجام دادن یک کار دیگر

- توابع باید یک کار را انجام دهند. باید خوب انجامش دهند. فقط باید این کار را انجام دهند.
-  دلیل اینکه ما توابع را می نویسیم، تجزیه مفهوم بزرگتر (به عبارت دیگر، نام تابع) در مجموعه مراحل در سطح بعدی انتزاع است.

## بخش‌های داخل توابع

-  توابعی که یک کار را انجام می‌دهند به طور منطقی نمی‌توانند به بخشها تقسیم شوند.

## یک سطح انتزاع به ازای هر تابع

- ترکیب سطوح مختلف انتزاع در یک تابع همیشه گیج‌کننده است. خوانندگان ممکن است نتوانند بگویند آیا یک عبارت خاص یک مفهوم اساسی است یا یک جز. بدتر ، مانند پنجره های شکسته ، هنگامی که جزئیات با مفاهیم اساسی مخلوط می‌شوند ، جزئیات بیشتر و بیشتری تمایل به پیوستن به درون تابع دارند.

## خواندن کد از بالا به پایین: قاعده گام به گام

- می‌خواهیم کد مانند روایتی از بالا به پایین خوانده شود.
-  می‌خواهیم هر تابع با سطح بعدی انتزاع دنبال شود تا بتوانیم برنامه را بخوانیم،
-   در حالی که لیست توابع را می خوانیم، یک سطح انتزاع کم می شود. 
-   من این را قاعده گام به گام می‌نامم.
- هر تابع، تابع بعدی را معرفی می‌کند ، و هر تابع در یک سطح ثابت از انتزاع باقی می ماند.
## Switch Statements

- خیلی سخت است که switch statement کوچکی ساخت. حتی یک switch statement فقط با دو مورد بزرگتر از آن است که دوست داشته باشم یک بلوک یا یک عملکرد باشد. حتی ساختن یک switch statement که یک کار انجام دهد، سخت است.
- 

## استفاده از نام‌های توصیفی

- وقتی هر روال تقریباً همان چیزی است که انتظار داشتید، آن موقع دارید تمیز کد میزنید.
- انتخاب نام‌های خوب برای توابع کوچکی است که یک کار را انجام می‌دهند. هرچه تابعی کوچکتر و متمرکزتر باشد، انتخاب نام توصیفی آسان‌تر است.
- از ایجاد نام طولانی نترسید. یک نام توصیفی طولانی بهتر از یک اسم مبهم کوتاه است. یک نام توصیفی طولانی بهتر از یک توضیحات توصیفی طولانی است.
- از یک قرارداد نامگذاری استفاده کنید که اجازه می‌دهد چندین کلمه به راحتی در نام‌های تابع خوانده شود ، و سپس از آن کلمات چندگانه استفاده کنید تا یک نامی برای تابع انتحاب کنید که می گوید چه کاری انجام می‌دهد.
- از صرف وقت خود برای انتخاب نام نترسید. در واقع ، شما باید چندین نام مختلف را امتحان کنید و کد را با هر یک از نام‌ها در محل بخوانید.
-  تا زمانی انجام دهید که یکی از آنها، به همان توصیفی است که کد را نوشتید.
-  در نامگذاری یکپارچه عمل کنید. از همان عبارات ، اسمها و افعال در نام‌های تابع استفاده کنید که برای ماژول های خود انتخاب می کنید.

## آرگومان های تابع

- تعداد ایده‌آل آرگومان برای یک تابع صفر است (niladic). بعدی یک (monadic) و درنهایت دو (dyadic). در صورت امکان باید از سه آرگومان (triadic) اجتناب شود. بیش از سه مورد (polyadic) نیاز به توجیه بسیار ویژه دارند - و به هر حال نباید از آنها استفاده کرد.
- آرگومان حتی از نقطه نظر تست هم سخت است. مشکل در نوشتن تمام موارد تست را تصور کنید تا اطمینان حاصل شود که تمام ترکیبات مختلف آرگومان ها به درستی کار می کنند.
  -  اگر آرگومانی وجود نداشته باشد ، این مسائل دیگر مهم نیستند.
  -  اگر یک آرگومان وجود داشته باشد ، خیلی سخت نیست.
  -  با دو آرگومان ، این مسئله کمی چالش برانگیزتر می شود.
  -   با بیش از دو آرگومان ، تست هر ترکیبی از مقادیر مناسب می تواند دلهره آور باشد.
**بعد بدون آرگومان، یک آرگومان ورودی بهترین است.**

## فرم رایج Monadic

- دو دلیل بسیار رایج برای دادن یک آرگومان به تابع وجود دارد.
 - چک کردن چیزی
 -  یا ممکن است شما بر اساس آن آرگومان کار کنید ، آن را به چیز دیگری تبدیل کرده و برگردانید.

## آرگومان های پرچم

- آرگومان های پرچم زشت هستند. دادن یک بولین به تابع یک عمل واقعاً وحشتناک است. بلافاصله امضای تابع را پیچیده می‌کند و با صدای بلند می گوید که این تابع بیشتر از یک کار را انجام می‌دهد.
-  اگر پرچم درست باشد یک کار، و اگر پرچم نادرست باشد یک کار دیگر را انجام می‌دهد!

## توابع Dyadic

- درک تابع دو آرگومانی، سختتر از تابع تک آرگومانی است.
- تکی  سرسری ، به راحتی معنی آن را می رساند. مورد دوتایی به مکث کوتاه نیاز . قسمت هایی که نادیده می گیریم جایی است که اشکالات در آن پنهان می‌شوند.دارد تا بفهمیم پارامترچه میگویند
- دو آرگومانی ها شر نیستند و مطمئناً باید آنها را بنویسید. با این حال ، باید بدانید که هزینه دارند و باید از مکانیسم هایی که در دسترس شماست، آنان را تبدیل به تک آرگومانی کنید.

## سه آرگومانی

- توابعی که سه آرگومان را در بر می گیرد درکشان به مراتب سخت تر از دو آرگومانی هاست. مسائلی مانند ترتیب ، مکث و نادیده گرفتن، بیش از دو برابر شده است. پیشنهاد می‌کنم قبل از ایجاد یک تابع سه آرگومانه ، خیلی با دقت فکر کنید.
- ممکن است کاهش تعداد آرگومان ها با ایجاد آبجکت های خارج از آنها تقلب به نظر برسد ، اما اینگونه نیست. وقتی گروههای متغیر با هم داده می‌شوند ، مثلا x و y در مثال بالا، احتمالاً بخشی از یک مفهوم هستند که سزاوار اسمی برای خود هستند.

## لیست های آرگومان

- توابعی که آرگومانهای متغیر میگیرند، می توانند تک آرگومانی، دو آرگومانی و یا حتی سه آرگومانی باشند. اما این اشتباه است که آرگومان های بیشتری را به آن دهیم.

## افعال و کیوردها

- انتخاب نام‌های خوب برای یک تابع می تواند شروع کننده یک راه طولانی برای توضیح هدف تابع و ترتیب و هدف آرگومان ها باشد. 
-  در مورد توابع تک آرگومانی، تابع و آرگومان باید یک جفت فعل/اسم بسیار زیبا را باشند.
  -  write(name) 
  -  حتی یک نام بهتر، میتواند writeField(name) باشد که میگوید “name” یک “field” است.
  -  assertEquals بهتر است به شکل assertExpectedEqualsActual(expected, actual) نوشته شود. این، به شدت مشکل یادآوری ترتیب آرگومان ها را کاهش می‌دهد.

## نداشتن هیچ عوارض جانبی

- عوارض جانبی دروغ است. تابع شما قول انجام یک کار را می‌دهد ، اما کارهای پنهان دیگری را نیز انجام می‌دهد. بعضی اوقات تغییرات غیرمنتظره ای در متغیرهای کلاس خاص خود ایجاد می‌کند.
- هرچیزی که شمارا مجبور به چک کردن امضا تابع کند، دوباره کاریست. یک حواس پرتیست که باید از آن اجتناب شود.

## جداسازی رایج Query

- **توابع یا باید کاری انجام دهند یا به چیزی پاسخ دهند ، اما نه هر دو اینها.**
 یا تابع شما باید وضعیت یک شی را تغییر دهد ، یا باید برخی از اطلاعات مربوط به آن شی را برگرداند. انجام هر دو، اغلب منجر به سردرگمی می شود.
 
 ## ترجیح Exception ها نسبت به برگرداندن کد خطا

- هنگامی که یک کد خطا را برگردانید ، این مشکل را ایجاد می کنید که صدازننده باید بلافاصله با خطا دست و پنجه نرم کند.
-  اگر به جای کدهای خطای برگشتی از exceptionها استفاده می کنید ، می‌توانید پردازش کد خطا را از مسیر کد جدا کرده و ساده سازی شود.

## استخراج بلوک های Try/Catch

- بلوک های try/catch در نوع خود زشت هستند. ساختار کد را گیج کننده می کنند و پردازش خطا را با پردازش عادی مخلوط می کنند. بنابراین بهتر است بدنه بلوک های try/catch را استخراج کنید و توابع مربوطه را بنویسید.

## مدیریت خطا یک چیز است

- توابع باید یک کار را انجام دهند. مدیریت خطا نیز یک کار است. بنابراین ، تابعی که مدیریت خطاها را انجام می‌دهد ، نباید کاری دیگر انجام دهد. 
-  اگر کلمه کلیدی try در یک تابع وجود داشته باشد ، باید اولین کلمه در تابع باشد و بعد از بلوک های catch/finally نیز چیزی نباید وجود داشته باشد.

## آهنربای وابستگی Error.java

- 

## خود را تکرار نکنید

- تکثیر یک مشکل است زیرا کد را منبسط می‌کند 
-  در صورت نیاز به تغییر الگوریتم نیاز به اصلاح چهار برابری دارد
- همچنین امکان خطا چهار برابری برای حذف نکردن آن صورت می گیرد
- تکثیر ممکن است ریشه همه شر در نرم افزار باشد.
- برنامه‌نویسی ساخت یافته، برنامه‌نویسی جهت گرا و برنامه‌نویسی مؤلفه ای ، کاملاً استراتژی هایی برای از بین بردن تکثیر است.

## برنامه‌نویسی ساخت یافته

- برخی از برنامه‌نویسان از قوانین برنامه‌نویسی ساخت یافته Edsger Dijkstra پیروی می کنند.
-  Dijkstra گفت كه هر تابع و هر بلوك درون یك تابع باید دارای یك ورودی و یك خروجی باشد. 
- فقط باید یک عبارت برگشتی در یک تابع داشته باشید ، بدون break یا continue در یک loop، وهرگز، بدون goto. 
- وقتی توابع بسیار کوچک باشند ، این قوانین سود کمتری دارند. فقط در توابع بزرگتر اینگونه قوانین مزایای قابل توجهی را ارائه می‌دهند.
-  اگر توابع خود را کوچک نگه دارید، چندین return ،break یا continue هیچ ضرری ندارد و حتی گاهی حتی می تواند بیانگرتر از قانون تک ورودی، تک خروجی باشد. از طرف دیگر، goto فقط در عملکردهای بزرگ معنی دارد، بنابراین باید از آن اجتناب کرد.

## چگونه می‌توانید توابعی مانند این را بنویسید؟

- نوشتن نرم افزار مانند هر نوع نوشتن دیگر است.
- وقتی مقاله ای می نویسید ، ابتدا افکار خود را می نویسید ، سپس با آن ور می روید تا خوب خوانا شود.
- پیش نویس اول ممکن است دست و پا چلفتی و سازماندهی نشده باشد ، بنابراین شما آنرا کلمه بندی می کنید ، آنرا دوباره سازی کرده و مجدداً آن را اصلاح می کنید تا اینکه خواننده مطالب را آنطور بخواند که می خواهید.
- وقتی توابع را می نویسم، طولانی و پیچیده می‌شوند. حلقه های تو در تو و درهم زیادی دارند. دارای لیست طولانی آرگومان هستند. نام‌ها دلبخواه هستند و کد تکراری نیز وجود دارد. اما من همچنین یک مجموعه تست واحد دارم که هرکدام از آن خطوط دست و پا چلفتی کد را پوشش می‌دهد.
- بنابراین ، آن کد را مشت و مال داده و اصلاح می‌کنم ، توابع را تقسیم می‌کنم ، نام‌ها را تغییر می دهم و تکرار را حذف می‌کنم. متدها را کوچک می‌کنم و دوباره مرتبشان می‌کنم. بعضی اوقات کلاس ها را که تست ها را پشت سر گذاشتند، حذف میکنم.
- در پایان ، توابعی باقی می مانند که از قوانینی که در این فصل تنظیم کرده ام پیروی می کنند. 
- **در شروع، آنان را به این شکل نمی نویسم. فکر نمی‌کنم کسی بتواند.**

## نتیجه گیری

- برنامه‌نویسان ارشد ، سیستم ها را به عنوان داستان هایی که باید گفته شود فکر می کنند نه برنامه‌هایی که باید نوشته شوند.
- آنها از امکانات زبان برنامه‌نویسی انتخاب شده خود برای ساختن زبانی بسیار غنی تر و رساتر استفاده می کنند که می توان برای گفتن آن داستان استفاده کرد.
